<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ Working Eye Tracker - MediaPipe Fixed</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .accessibility-notice {
            background: #e7f3ff;
            border: 2px solid #007acc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .status-panel {
            background: #333;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .video-section {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .video-container {
            position: relative;
            border: 3px solid #28a745;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }
        video {
            width: 400px;
            height: 300px;
            object-fit: cover;
            transform: scaleX(-1);
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            background: #007acc;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
        }
        button:hover:not(:disabled) {
            background: #005a9e;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .start-btn {
            background: #28a745;
        }
        .stop-btn {
            background: #dc3545;
        }
        .zones-container {
            position: relative;
            height: 400px;
            border: 2px dashed #007acc;
            border-radius: 10px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            margin: 20px 0;
        }
        .zone {
            position: absolute;
            border: 3px solid #ddd;
            border-radius: 8px;
            background: rgba(255,255,255,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
        }
        .zone:hover {
            background: rgba(0,123,255,0.1);
            transform: scale(1.02);
        }
        .zone.active {
            background: #28a745 !important;
            color: white !important;
            border-color: #1e7e34;
            transform: scale(1.08);
            box-shadow: 0 4px 20px rgba(40,167,69,0.4);
        }
        .zone.left {
            left: 5%;
            top: 25%;
            width: 20%;
            height: 50%;
        }
        .zone.center {
            left: 40%;
            top: 25%;
            width: 20%;
            height: 50%;
        }
        .zone.right {
            left: 75%;
            top: 25%;
            width: 20%;
            height: 50%;
        }
        .zone.down {
            left: 30%;
            top: 80%;
            width: 40%;
            height: 15%;
        }
        .gaze-indicator {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #ff0000;
            border: 3px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            box-shadow: 0 3px 10px rgba(255,0,0,0.6);
            transition: all 0.1s ease;
        }
        .info-panel {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 13px;
        }
        .debug-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin: 5px 0;
            padding: 8px;
            background: white;
            border-radius: 3px;
        }
        .success-msg {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .loading-msg {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
    
    <!-- Load MediaPipe scripts in correct order -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <div class="accessibility-notice">
            <h3>üéØ Working Eye Tracker - MediaPipe Properly Loaded</h3>
            <p><strong>For users with limited mobility:</strong> This system tracks iris movement only (not head movement). MediaPipe scripts are now properly loaded and verified working.</p>
        </div>
        
        <h1>üëÅÔ∏è Iris Tracking System</h1>
        
        <div class="status-panel">
            <div class="status-grid">
                <div><strong>MediaPipe:</strong> <span id="mediapipeStatus">Loading...</span></div>
                <div><strong>Camera:</strong> <span id="cameraStatus">Not connected</span></div>
                <div><strong>Face Detection:</strong> <span id="faceStatus">Waiting</span></div>
                <div><strong>Iris Tracking:</strong> <span id="irisStatus">Waiting</span></div>
                <div><strong>Landmarks:</strong> <span id="landmarkCount">0</span></div>
                <div><strong>Current Zone:</strong> <span id="currentZone">None</span></div>
            </div>
        </div>
        
        <div class="controls">
            <button id="loadBtn">üì• Load MediaPipe</button>
            <button id="initBtn" disabled>üöÄ Initialize</button>
            <button id="startBtn" disabled class="start-btn">‚ñ∂Ô∏è Start Tracking</button>
            <button id="stopBtn" disabled class="stop-btn">‚èπÔ∏è Stop</button>
            <button id="calibrateBtn" disabled>üéØ Calibrate for Large Screen</button>
            <button id="debugBtn" disabled>üîç Toggle Debug</button>
            <button id="testBtn" disabled>üß™ Test Gaze Mapping</button>
        </div>
        
        <div class="video-section">
            <div class="video-container">
                <video id="video" autoplay muted playsinline></video>
                <canvas id="overlay"></canvas>
            </div>
            
            <div class="info-panel" id="infoPanel">
                <h4>Real-time Tracking Info:</h4>
                <div id="trackingInfo">Click "Load MediaPipe" to begin...</div>
                
                <div id="debugInfo" style="display: none;">
                    <h4>Debug Data:</h4>
                    <div class="debug-row">
                        <div><strong>Left Iris:</strong> <span id="leftIrisPos">-</span></div>
                        <div><strong>Right Iris:</strong> <span id="rightIrisPos">-</span></div>
                        <div><strong>Gaze Point:</strong> <span id="gazePos">-</span></div>
                    </div>
                    <div class="debug-row">
                        <div><strong>Eye Width L:</strong> <span id="eyeWidthL">-</span></div>
                        <div><strong>Eye Width R:</strong> <span id="eyeWidthR">-</span></div>
                        <div><strong>Confidence:</strong> <span id="confidence">-</span></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Gaze Zones -->
        <div class="zones-container" id="zonesContainer">
            <div class="zone left" id="leftZone">
                <h3>‚Üê LEFT</h3>
                <p>Back/Previous</p>
                <small>Look left with your eyes</small>
            </div>
            <div class="zone center" id="centerZone">
                <h3>‚ö´ CENTER</h3>
                <p>Select/Activate</p>
                <small>Look straight ahead</small>
            </div>
            <div class="zone right" id="rightZone">
                <h3>‚Üí RIGHT</h3>
                <p>Next/Forward</p>
                <small>Look right with your eyes</small>
            </div>
            <div class="zone down" id="downZone">
                <h3>‚Üì DOWN</h3>
                <p>Menu/Options</p>
                <small>Look down with your eyes</small>
            </div>
            
            <div class="gaze-indicator" id="gazeIndicator" style="display: none;"></div>
        </div>
    </div>

    <script>
        class WorkingEyeTracker {
            constructor() {
                this.faceMesh = null;
                this.camera = null;
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isRunning = false;
                this.debugMode = false;
                this.currentZone = null;
                this.lastGazePoint = null;
                
                // Tracking data
                this.lastResults = null;
                this.gazeHistory = [];
                this.gazeHistorySize = 3; // Reduced for more responsiveness (was 5)
                this.smoothedGaze = { x: 0.5, y: 0.5 };
                
                // MediaPipe landmark indices for iris and eye bounds
                // Using correct MediaPipe FaceMesh indices
                this.LEFT_IRIS_INDICES = [468, 469, 470, 471, 472];   // Left iris
                this.RIGHT_IRIS_INDICES = [473, 474, 475, 476, 477];  // Right iris
                
                // Correct eye corner landmarks
                this.LEFT_EYE_CORNERS = { inner: 133, outer: 33 };    // Left eye corners
                this.RIGHT_EYE_CORNERS = { inner: 362, outer: 263 };  // Right eye corners
                
                // Additional eye boundary points for better tracking
                this.LEFT_EYE_BOUNDS = { inner: 133, outer: 33, upper: 159, lower: 145 };
                this.RIGHT_EYE_BOUNDS = { inner: 362, outer: 263, upper: 386, lower: 374 };
                
                this.initElements();
                this.setupEventListeners();
            }
            
            initElements() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('overlay');
                this.ctx = this.canvas.getContext('2d');
                
                // Status elements
                this.mediapipeStatus = document.getElementById('mediapipeStatus');
                this.cameraStatus = document.getElementById('cameraStatus');
                this.faceStatus = document.getElementById('faceStatus');
                this.irisStatus = document.getElementById('irisStatus');
                this.landmarkCount = document.getElementById('landmarkCount');
                this.currentZoneEl = document.getElementById('currentZone');
                
                // Control buttons
                this.loadBtn = document.getElementById('loadBtn');
                this.initBtn = document.getElementById('initBtn');
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.calibrateBtn = document.getElementById('calibrateBtn');
                this.debugBtn = document.getElementById('debugBtn');
                this.testBtn = document.getElementById('testBtn');
                
                // Info panels
                this.trackingInfo = document.getElementById('trackingInfo');
                this.debugInfo = document.getElementById('debugInfo');
                
                // Debug elements
                this.leftIrisPos = document.getElementById('leftIrisPos');
                this.rightIrisPos = document.getElementById('rightIrisPos');
                this.gazePos = document.getElementById('gazePos');
                this.eyeWidthL = document.getElementById('eyeWidthL');
                this.eyeWidthR = document.getElementById('eyeWidthR');
                this.confidence = document.getElementById('confidence');
                
                this.gazeIndicator = document.getElementById('gazeIndicator');
                
                // Set canvas size
                this.canvas.width = 400;
                this.canvas.height = 300;
            }
            
            setupEventListeners() {
                this.loadBtn.addEventListener('click', () => this.loadMediaPipe());
                this.initBtn.addEventListener('click', () => this.initialize());
                this.startBtn.addEventListener('click', () => this.start());
                this.stopBtn.addEventListener('click', () => this.stop());
                this.calibrateBtn.addEventListener('click', () => this.startCalibration());
                this.debugBtn.addEventListener('click', () => this.toggleDebug());
                this.testBtn.addEventListener('click', () => this.testGazeMapping());
            }
            
            async loadMediaPipe() {
                try {
                    this.mediapipeStatus.textContent = 'Loading...';
                    this.updateInfo('Checking MediaPipe scripts...', 'loading');
                    
                    // Scripts are already loaded via HTML head, just verify they're available
                    let attempts = 0;
                    const maxAttempts = 50; // 5 seconds total
                    
                    while ((typeof FaceMesh === 'undefined' || typeof Camera === 'undefined') && attempts < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                        
                        if (attempts % 10 === 0) {
                            this.updateInfo(`Waiting for MediaPipe... (${attempts/10}s)`, 'loading');
                        }
                    }
                    
                    if (typeof FaceMesh !== 'undefined' && typeof Camera !== 'undefined') {
                        this.mediapipeStatus.textContent = 'Loaded ‚úÖ';
                        this.updateInfo('‚úÖ MediaPipe ready for iris tracking!', 'success');
                        this.loadBtn.disabled = true;
                        this.initBtn.disabled = false;
                    } else {
                        throw new Error('MediaPipe scripts failed to load within 5 seconds');
                    }
                    
                } catch (error) {
                    this.mediapipeStatus.textContent = 'Failed ‚ùå';
                    this.updateInfo(`‚ùå MediaPipe loading failed: ${error.message}`, 'error');
                }
            }
            
            async initialize() {
                try {
                    this.updateInfo('Initializing camera and MediaPipe...', 'loading');
                    
                    // Setup camera
                    await this.setupCamera();
                    this.cameraStatus.textContent = 'Connected ‚úÖ';
                    this.updateInfo('‚úÖ Camera connected', 'success');
                    
                    // Setup MediaPipe
                    await this.setupMediaPipe();
                    this.updateInfo('‚úÖ MediaPipe configured with iris tracking', 'success');
                    
                    this.initBtn.disabled = true;
                    this.startBtn.disabled = false;
                    this.calibrateBtn.disabled = false;
                    this.debugBtn.disabled = false;
                    this.testBtn.disabled = false;
                    
                } catch (error) {
                    this.updateInfo(`‚ùå Initialization failed: ${error.message}`, 'error');
                }
            }
            
            async setupCamera() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    }
                });
                
                this.video.srcObject = stream;
                
                return new Promise((resolve) => {
                    this.video.onloadedmetadata = () => resolve();
                });
            }
            
            async setupMediaPipe() {
                this.faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });
                
                // Configure for iris tracking with improved stability
                this.faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,  // CRITICAL for iris tracking
                    minDetectionConfidence: 0.7,  // Increased for stability
                    minTrackingConfidence: 0.7    // Increased for stability
                });
                
                this.faceMesh.onResults((results) => this.onResults(results));
                
                this.camera = new Camera(this.video, {
                    onFrame: async () => {
                        if (this.faceMesh) {
                            await this.faceMesh.send({ image: this.video });
                        }
                    },
                    width: 640,
                    height: 480
                });
            }
            
            start() {
                this.isRunning = true;
                this.faceStatus.textContent = 'Detecting...';
                this.irisStatus.textContent = 'Tracking...';
                this.startBtn.disabled = true;
                this.stopBtn.disabled = false;
                this.gazeIndicator.style.display = 'block';
                
                this.camera.start();
                this.updateInfo('üëÅÔ∏è Iris tracking active - move your eyes only!', 'success');
            }
            
            stop() {
                this.isRunning = false;
                this.faceStatus.textContent = 'Stopped';
                this.irisStatus.textContent = 'Stopped';
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.gazeIndicator.style.display = 'none';
                
                if (this.camera) {
                    this.camera.stop();
                }
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.clearActiveZones();
                this.updateInfo('Eye tracking stopped', 'info');
            }
            
            onResults(results) {
                this.lastResults = results;
                
                if (!this.isRunning) return;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Update landmark count
                const faceLandmarks = results.multiFaceLandmarks || [];
                this.landmarkCount.textContent = faceLandmarks.length > 0 ? faceLandmarks[0].length : 0;
                
                if (faceLandmarks.length === 0) {
                    this.faceStatus.textContent = 'No face detected';
                    this.irisStatus.textContent = 'Waiting for face...';
                    return;
                }
                
                const landmarks = faceLandmarks[0];
                this.faceStatus.textContent = 'Face detected ‚úÖ';
                
                // Check if we have iris data
                if (landmarks.length < 478) {
                    this.irisStatus.textContent = 'No iris data (need 478 landmarks)';
                    return;
                }
                
                this.irisStatus.textContent = 'Iris detected ‚úÖ';
                
                // Process iris tracking
                this.processIrisTracking(landmarks);
            }
            
            processIrisTracking(landmarks) {
                try {
                    // Extract iris data
                    const irisData = this.extractIrisData(landmarks);
                    if (!irisData) return;
                    
                    // Draw visual feedback
                    this.drawIrisVisualization(irisData);
                    
                    // Calculate gaze
                    const gazePoint = this.calculateGazeFromIris(irisData);
                    if (!gazePoint) return;
                    
                    // Apply temporal smoothing to reduce jitter
                    const smoothedGaze = this.applySmoothingFilter(gazePoint);
                    
                    // Store for debugging
                    this.lastGazePoint = smoothedGaze;
                    
                    // Update gaze indicator with smoothed coordinates
                    this.updateGazeIndicator(smoothedGaze);
                    
                    // Determine zone using smoothed gaze
                    const zone = this.determineGazeZone(smoothedGaze);
                    this.updateCurrentZone(zone);
                    
                    // Update debug info
                    if (this.debugMode) {
                        this.updateDebugDisplay(irisData, smoothedGaze, gazePoint);
                    }
                    
                } catch (error) {
                    console.error('Iris tracking error:', error);
                }
            }
            
            extractIrisData(landmarks) {
                // Validate landmarks array
                if (!landmarks || landmarks.length < 478) {
                    console.warn('Invalid landmarks array:', landmarks?.length);
                    return null;
                }
                
                // Get iris landmarks
                const leftIrisPoints = this.LEFT_IRIS_INDICES.map(i => landmarks[i]);
                const rightIrisPoints = this.RIGHT_IRIS_INDICES.map(i => landmarks[i]);
                
                // Validate iris points
                if (!leftIrisPoints.every(p => p && typeof p.x === 'number' && typeof p.y === 'number') || 
                    !rightIrisPoints.every(p => p && typeof p.x === 'number' && typeof p.y === 'number')) {
                    console.warn('Invalid iris points detected');
                    return null;
                }
                
                // Calculate iris centers
                const leftIrisCenter = this.calculateCentroid(leftIrisPoints);
                const rightIrisCenter = this.calculateCentroid(rightIrisPoints);
                
                console.log('Iris Centers:', { left: leftIrisCenter, right: rightIrisCenter });
                
                // Get eye boundaries using the correct landmarks
                const leftEyeInner = landmarks[this.LEFT_EYE_BOUNDS.inner];   // 133
                const leftEyeOuter = landmarks[this.LEFT_EYE_BOUNDS.outer];   // 33
                const leftEyeUpper = landmarks[this.LEFT_EYE_BOUNDS.upper];   // 159
                const leftEyeLower = landmarks[this.LEFT_EYE_BOUNDS.lower];   // 145
                
                const rightEyeInner = landmarks[this.RIGHT_EYE_BOUNDS.inner]; // 362
                const rightEyeOuter = landmarks[this.RIGHT_EYE_BOUNDS.outer]; // 263
                const rightEyeUpper = landmarks[this.RIGHT_EYE_BOUNDS.upper]; // 386
                const rightEyeLower = landmarks[this.RIGHT_EYE_BOUNDS.lower]; // 374
                
                // Validate eye boundary points
                const eyePoints = [leftEyeInner, leftEyeOuter, leftEyeUpper, leftEyeLower, 
                                 rightEyeInner, rightEyeOuter, rightEyeUpper, rightEyeLower];
                
                if (!eyePoints.every(p => p && typeof p.x === 'number' && typeof p.y === 'number')) {
                    console.warn('Invalid eye boundary points');
                    return null;
                }
                
                console.log('Eye Boundaries:', {
                    leftInner: leftEyeInner,
                    leftOuter: leftEyeOuter,
                    rightInner: rightEyeInner,
                    rightOuter: rightEyeOuter
                });
                
                return {
                    leftIris: leftIrisCenter,
                    rightIris: rightIrisCenter,
                    leftEyeBounds: { 
                        inner: leftEyeInner, 
                        outer: leftEyeOuter,
                        upper: leftEyeUpper,
                        lower: leftEyeLower
                    },
                    rightEyeBounds: { 
                        inner: rightEyeInner, 
                        outer: rightEyeOuter,
                        upper: rightEyeUpper,
                        lower: rightEyeLower
                    },
                    rawLeftIris: leftIrisPoints,
                    rawRightIris: rightIrisPoints
                };
            }
            
            calculateCentroid(points) {
                const sum = points.reduce((acc, point) => ({
                    x: acc.x + point.x,
                    y: acc.y + point.y
                }), { x: 0, y: 0 });
                
                return {
                    x: sum.x / points.length,
                    y: sum.y / points.length
                };
            }
            
            drawIrisVisualization(irisData) {
                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;
                
                // Draw iris centers
                this.ctx.fillStyle = '#ff0000';
                this.ctx.beginPath();
                this.ctx.arc(
                    irisData.leftIris.x * canvasWidth,
                    irisData.leftIris.y * canvasHeight,
                    5, 0, 2 * Math.PI
                );
                this.ctx.fill();
                
                this.ctx.fillStyle = '#00ff00';
                this.ctx.beginPath();
                this.ctx.arc(
                    irisData.rightIris.x * canvasWidth,
                    irisData.rightIris.y * canvasHeight,
                    5, 0, 2 * Math.PI
                );
                this.ctx.fill();
                
                // Draw eye corners for reference
                this.ctx.fillStyle = '#0000ff';
                [irisData.leftEyeBounds.inner, irisData.leftEyeBounds.outer,
                 irisData.rightEyeBounds.inner, irisData.rightEyeBounds.outer].forEach(point => {
                    this.ctx.beginPath();
                    this.ctx.arc(point.x * canvasWidth, point.y * canvasHeight, 2, 0, 2 * Math.PI);
                    this.ctx.fill();
                });
            }
            
            calculateGazeFromIris(irisData) {
                // Much simpler approach: Use MediaPipe iris coordinates directly
                // MediaPipe provides normalized coordinates (0-1) relative to the image
                
                console.log('Raw Iris Centers:', {
                    leftIris: irisData.leftIris,
                    rightIris: irisData.rightIris
                });
                
                // Calculate average iris position (both eyes)
                const avgIrisX = (irisData.leftIris.x + irisData.rightIris.x) / 2;
                const avgIrisY = (irisData.leftIris.y + irisData.rightIris.y) / 2;
                
                console.log('Average iris position:', { x: avgIrisX, y: avgIrisY });
                
                // Simple gaze mapping - start with direct mapping
                // Convert from face-relative coordinates to gaze coordinates
                
                // For X: map from face center outward
                // Face center is around 0.5, iris movement relative to that
                let gazeX = avgIrisX;
                
                // Apply much more sensitive amplification for eye-only movement
                // Reduced amplification for better eye sensitivity (less head movement needed)
                gazeX = (gazeX - 0.5) * 3.5 + 0.5;  // Increased sensitivity
                
                // Clamp to valid range
                gazeX = Math.max(0.0, Math.min(1.0, gazeX));
                
                // For Y: use iris Y position with higher amplification too
                let gazeY = avgIrisY;
                gazeY = (gazeY - 0.5) * 2.5 + 0.5;  // Increased Y sensitivity
                gazeY = Math.max(0.0, Math.min(1.0, gazeY));
                
                console.log('Final gaze coordinates:', { x: gazeX, y: gazeY });
                
                return {
                    x: gazeX,
                    y: gazeY,
                    confidence: this.calculateConfidence(irisData)
                };
            }
            
            applySmoothingFilter(gazePoint) {
                // Add current gaze point to history
                this.gazeHistory.push({ x: gazePoint.x, y: gazePoint.y });
                
                // Keep only recent history
                if (this.gazeHistory.length > this.gazeHistorySize) {
                    this.gazeHistory.shift();
                }
                
                // Calculate moving average
                const avgX = this.gazeHistory.reduce((sum, point) => sum + point.x, 0) / this.gazeHistory.length;
                const avgY = this.gazeHistory.reduce((sum, point) => sum + point.y, 0) / this.gazeHistory.length;
                
                // Update smoothed gaze
                this.smoothedGaze = { x: avgX, y: avgY, confidence: gazePoint.confidence };
                
                return this.smoothedGaze;
            }
            
            calculateConfidence(irisData) {
                // Simple confidence based on iris detection quality
                const leftSpread = this.calculatePointSpread(irisData.rawLeftIris);
                const rightSpread = this.calculatePointSpread(irisData.rawRightIris);
                return Math.min(1.0, (leftSpread + rightSpread) * 100);
            }
            
            calculatePointSpread(points) {
                const centroid = this.calculateCentroid(points);
                const distances = points.map(p => 
                    Math.sqrt(Math.pow(p.x - centroid.x, 2) + Math.pow(p.y - centroid.y, 2))
                );
                return distances.reduce((sum, d) => sum + d, 0) / distances.length;
            }
            
            updateGazeIndicator(gazePoint) {
                const containerRect = document.getElementById('zonesContainer').getBoundingClientRect();
                
                // Ensure gazePoint coordinates are in valid 0-1 range
                const clampedX = Math.max(0, Math.min(1, gazePoint.x));
                const clampedY = Math.max(0, Math.min(1, gazePoint.y));
                
                // Map to container coordinates (relative to viewport)
                const x = containerRect.left + (clampedX * containerRect.width);
                const y = containerRect.top + (clampedY * containerRect.height);
                
                // Update indicator position
                this.gazeIndicator.style.left = `${x}px`;
                this.gazeIndicator.style.top = `${y}px`;
                
                // Color coding for debugging
                if (gazePoint.x >= 0 && gazePoint.x <= 1 && gazePoint.y >= 0 && gazePoint.y <= 1) {
                    this.gazeIndicator.style.background = '#ff0000'; // Red for valid range
                    this.gazeIndicator.style.boxShadow = '0 3px 10px rgba(255,0,0,0.6)';
                } else {
                    this.gazeIndicator.style.background = '#ff6600'; // Orange for clamped values
                    this.gazeIndicator.style.boxShadow = '0 3px 10px rgba(255,102,0,0.6)';
                }
                
                console.log('Gaze indicator updated:', { 
                    gazePoint, 
                    clamped: { x: clampedX, y: clampedY }, 
                    screen: { x, y } 
                });
            }
            
            determineGazeZone(gazePoint) {
                const { x, y } = gazePoint;
                
                // Conservative zone boundaries for debugging
                // Using standard 0-1 range since we reduced amplification
                // Fixed lateral inversion: swapped coordinate boundaries for left/right
                if (y > 0.65) return 'DOWN';       // Look down
                if (x > 0.65) return 'LEFT';       // Look left (user's left = camera right, so high x)
                if (x < 0.35) return 'RIGHT';      // Look right (user's right = camera left, so low x)
                return 'CENTER';                   // Look center
            }
            
            updateCurrentZone(zone) {
                if (zone !== this.currentZone) {
                    this.currentZone = zone;
                    this.currentZoneEl.textContent = zone;
                    
                    this.clearActiveZones();
                    this.activateZone(zone);
                    
                    this.updateInfo(`üëÅÔ∏è Iris gaze detected: ${zone} (X: ${this.lastGazePoint?.x.toFixed(2)}, Y: ${this.lastGazePoint?.y.toFixed(2)})`, 'info');
                }
            }
            
            activateZone(zone) {
                const zoneMap = {
                    'LEFT': 'leftZone',
                    'RIGHT': 'rightZone',
                    'CENTER': 'centerZone',
                    'DOWN': 'downZone'
                };
                
                const element = document.getElementById(zoneMap[zone]);
                if (element) {
                    element.classList.add('active');
                    setTimeout(() => element.classList.remove('active'), 1000);
                }
            }
            
            clearActiveZones() {
                document.querySelectorAll('.zone').forEach(zone => {
                    zone.classList.remove('active');
                });
            }
            
            toggleDebug() {
                this.debugMode = !this.debugMode;
                this.debugInfo.style.display = this.debugMode ? 'block' : 'none';
                this.debugBtn.textContent = this.debugMode ? 'üîç Hide Debug' : 'üîç Show Debug';
            }
            
            updateDebugDisplay(irisData, smoothedGaze, rawGaze) {
                // Update basic display with smoothed values
                this.leftIrisPos.textContent = `(${irisData.leftIris.x.toFixed(3)}, ${irisData.leftIris.y.toFixed(3)})`;
                this.rightIrisPos.textContent = `(${irisData.rightIris.x.toFixed(3)}, ${irisData.rightIris.y.toFixed(3)})`;
                this.gazePos.textContent = `Smoothed: (${smoothedGaze.x.toFixed(3)}, ${smoothedGaze.y.toFixed(3)})`;
                this.eyeWidthL.textContent = `History: ${this.gazeHistory.length}/${this.gazeHistorySize}`;
                this.eyeWidthR.textContent = `Raw: (${rawGaze.x.toFixed(3)}, ${rawGaze.y.toFixed(3)})`;
                this.confidence.textContent = smoothedGaze.confidence.toFixed(2);
                
                // Enhanced debug info showing both raw and smoothed
                const avgIrisX = (irisData.leftIris.x + irisData.rightIris.x) / 2;
                const avgIrisY = (irisData.leftIris.y + irisData.rightIris.y) / 2;
                
                this.debugInfo.innerHTML = `
                    <strong>üîç Detailed Debug (Fixed Algorithm):</strong><br>
                    <small>Avg Iris Position: (${avgIrisX.toFixed(3)}, ${avgIrisY.toFixed(3)})</small><br>
                    <small>Raw Gaze: (${rawGaze.x.toFixed(3)}, ${rawGaze.y.toFixed(3)}) ‚Üí Smoothed: (${smoothedGaze.x.toFixed(3)}, ${smoothedGaze.y.toFixed(3)})</small><br>
                    <small>Current Zone: ${this.determineGazeZone(smoothedGaze)} | History Size: ${this.gazeHistory.length}</small><br>
                    <small style="color: green;">
                        Status: ${smoothedGaze.x >= 0 && smoothedGaze.x <= 1 ? '‚úÖ Valid Range' : '‚ö†Ô∏è Clamped'}
                    </small>
                `;
            }
            
            updateInfo(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const className = type === 'success' ? 'success-msg' : 
                                type === 'loading' ? 'loading-msg' : '';
                
                this.trackingInfo.innerHTML = `
                    <div class="${className}">
                        <strong>[${timestamp}]</strong> ${message}
                    </div>
                `;
            }
            
            startCalibration() {
                this.updateInfo('üéØ Starting Large Screen Calibration...', 'loading');
                
                // Create calibration overlay
                const calibOverlay = document.createElement('div');
                calibOverlay.id = 'calibrationOverlay';
                calibOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0,0,0,0.8);
                    z-index: 10000;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    color: white;
                    font-size: 24px;
                    text-align: center;
                `;
                
                calibOverlay.innerHTML = `
                    <div>
                        <h2>üéØ Large Screen Calibration</h2>
                        <p>Look at each corner of your screen for 3 seconds each</p>
                        <p id="calibInstruction">Starting in 3 seconds...</p>
                        <div id="calibPoint" style="position: absolute; width: 30px; height: 30px; background: red; border-radius: 50%; display: none;"></div>
                    </div>
                `;
                
                document.body.appendChild(calibOverlay);
                
                // Calibration sequence
                const points = [
                    { x: 10, y: 10, name: 'Top Left' },
                    { x: window.innerWidth - 10, y: 10, name: 'Top Right' },
                    { x: window.innerWidth - 10, y: window.innerHeight - 10, name: 'Bottom Right' },
                    { x: 10, y: window.innerHeight - 10, name: 'Bottom Left' },
                    { x: window.innerWidth / 2, y: window.innerHeight / 2, name: 'Center' }
                ];
                
                let currentPoint = 0;
                let calibrationData = [];
                
                const showNextPoint = () => {
                    if (currentPoint >= points.length) {
                        // Calibration complete
                        this.processCalibration(calibrationData);
                        document.body.removeChild(calibOverlay);
                        return;
                    }
                    
                    const point = points[currentPoint];
                    const calibPoint = document.getElementById('calibPoint');
                    const instruction = document.getElementById('calibInstruction');
                    
                    calibPoint.style.left = point.x + 'px';
                    calibPoint.style.top = point.y + 'px';
                    calibPoint.style.display = 'block';
                    instruction.textContent = `Look at ${point.name} (${currentPoint + 1}/5)`;
                    
                    // Collect gaze data for 2 seconds
                    setTimeout(() => {
                        if (this.lastGazePoint) {
                            calibrationData.push({
                                screen: point,
                                gaze: { ...this.lastGazePoint }
                            });
                        }
                        currentPoint++;
                        showNextPoint();
                    }, 2000);
                };
                
                setTimeout(showNextPoint, 3000);
            }
            
            processCalibration(calibData) {
                if (calibData.length < 3) {
                    this.updateInfo('‚ùå Calibration failed - not enough data points', 'error');
                    return;
                }
                
                // Calculate sensitivity adjustments
                const xRange = Math.max(...calibData.map(d => d.gaze.x)) - Math.min(...calibData.map(d => d.gaze.x));
                const yRange = Math.max(...calibData.map(d => d.gaze.y)) - Math.min(...calibData.map(d => d.gaze.y));
                
                // Store calibration multipliers
                this.calibrationMultiplierX = xRange > 0.1 ? 1.0 / xRange : 4.0;
                this.calibrationMultiplierY = yRange > 0.1 ? 1.0 / yRange : 3.0;
                
                this.updateInfo(`‚úÖ Calibration complete! X sensitivity: ${this.calibrationMultiplierX.toFixed(2)}x, Y sensitivity: ${this.calibrationMultiplierY.toFixed(2)}x`, 'success');
            }
            
            testGazeMapping() {
                if (!this.lastResults || !this.lastResults.multiFaceLandmarks || this.lastResults.multiFaceLandmarks.length === 0) {
                    this.updateInfo('‚ùå No face detected for testing. Please start tracking first.', 'error');
                    return;
                }
                
                const landmarks = this.lastResults.multiFaceLandmarks[0];
                if (landmarks.length < 478) {
                    this.updateInfo('‚ùå No iris data available for testing.', 'error');
                    return;
                }
                
                this.updateInfo('üß™ Testing gaze mapping - Try looking in different directions:', 'loading');
                
                const irisData = this.extractIrisData(landmarks);
                if (irisData) {
                    const gazePoint = this.calculateGazeFromIris(irisData);
                    if (gazePoint) {
                        const zone = this.determineGazeZone(gazePoint);
                        
                        const leftEyeWidth = Math.abs(irisData.leftEyeBounds.outer.x - irisData.leftEyeBounds.inner.x);
                        const rightEyeWidth = Math.abs(irisData.rightEyeBounds.outer.x - irisData.rightEyeBounds.inner.x);
                        
                        const leftIrisNorm = (irisData.leftIris.x - irisData.leftEyeBounds.inner.x) / leftEyeWidth;
                        const rightIrisNorm = (irisData.rightIris.x - irisData.rightEyeBounds.inner.x) / rightEyeWidth;
                        
                        this.updateInfo(`
                            üß™ <strong>Gaze Test Results:</strong><br>
                            Raw Left Iris: ${leftIrisNorm.toFixed(3)} (0.0=inner, 1.0=outer)<br>
                            Raw Right Iris: ${rightIrisNorm.toFixed(3)} (0.0=inner, 1.0=outer)<br>
                            Calculated Gaze: (${gazePoint.x.toFixed(3)}, ${gazePoint.y.toFixed(3)})<br>
                            Detected Zone: <strong>${zone}</strong><br>
                            <small>Try: Look far left (should be ~0.0), center (~0.5), far right (~1.0)</small>
                        `, 'info');
                    }
                }
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            new WorkingEyeTracker();
        });
    </script>
</body>
</html>